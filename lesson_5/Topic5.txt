1.  How would you order this array of number strings by descending numeric
    value?

    arr = ['10', '11', '9', '7', '8']

    A:  arr.sort{|a, b| b.to_i <=> a.to_i}

2.  How would you order this array of hashes based on the year of publication
    of each book, from the earliest to the latest?

    books = [
      {title: 'One Hundred Years of Solitude', author: 'Gabriel Garcia
        Marquez', published: '1967'},
      {title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', published:
        '1925'},
      {title: 'War and Peace', author: 'Leo Tolstoy', published: '1869'},
      {title: 'Ulysses', author: 'James Joyce', published: '1922'}
    ]

    A:  books.sort_by{ |book| book[:published]}

3.  For each of these collection objects demonstrate how you would reference
    the letter 'g'.

    arr1 = ['a', 'b', ['c', ['d', 'e', 'f', 'g']]]

    A:  arr1[2][1][3]

    arr2 = [{first: ['a', 'b', 'c'], second: ['d', 'e', 'f']}, {third: ['g',
      'h', 'i']}]

    A:  arr2[1][:third][0]

    arr3 = [['abc'], ['def'], {third: ['ghi']}]

    A:  arr3[2][:third][0][0]

    hsh1 = {'a' => ['d', 'e'], 'b' => ['f', 'g'], 'c' => ['h', 'i']}

    A:  hsh1['b'][1]

    hsh2 = {first: {'d' => 3}, second: {'e' => 2, 'f' => 1}, third: {'g' => 0}}

    A:  hsh2[:third].key(0)

4.  For each of these collection objects where the value 3 occurs, demonstrate
    how you would change this to 4.

    arr1 = [1, [2, 3], 4]

    A:  arr1[1][1] = 4 or arr[1][1] += 1

    arr2 = [{a: 1}, {b: 2, c: [7, 6, 5], d: 4}, 3]

    A:  arr2[2] = 4 or arr2[2] += 1

    hsh1 = {first: [1, 2, [3]]}

    A:  hsh1[:first][2][0] = 4 or hsh1[:first][2][0] += 1

    hsh2 = {['a'] => {a: ['1', :two, 3], b: 4}, 'b' => 5}

    A:  hsh2[['a']][:a][2] = 4 or hsh2[['a']][:a][2] += 1

5.  Given this nested Hash:

    munsters = {
      "Herman" => { "age" => 32, "gender" => "male" },
      "Lily" => { "age" => 30, "gender" => "female" },
      "Grandpa" => { "age" => 402, "gender" => "male" },
      "Eddie" => { "age" => 10, "gender" => "male" },
      "Marilyn" => { "age" => 23, "gender" => "female"}
    }

    figure out the total age of just the male members of the family.

    A:  munsters.select{|k, v| v["gender"]=="male"}
        .map{|k, v| v["age"]}
        .reduce{|acc, elem| acc + elem}

6.  One of the most frequently used real-world string properties is that of
    "string substitution", where we take a hard-coded string and modify it with
    various parameters from our program. Given this previously seen family
    hash, print out the name, age and gender
    of each family member like this:
    (Name) is a (age)-year-old (male or female).

    A:  munsters.each{|k,v| puts "#{k} is a #{v["age"]}-year-old #{v["gender"]}."}

7.  Given this code, what would be the final values of a and b? Try to work
    this out without running the code.

        a = 2
        b = [5, 8]
        arr = [a, b]

        arr[0] += 2
        arr[1][0] -= a

    A:  a=2, b=[3, 8]

8.  Using the each method, write some code to output all of the vowels from the
    strings.

    hsh = {first: ['the', 'quick'], second: ['brown', 'fox'],
          third:['jumped'], fourth: ['over', 'the', 'lazy', 'dog']}

    A:    str = ''
          hsh.each do |_, v|
            v.each do |w|
              str << w.delete("^aeiouAEIOU")
            end
          end
          puts str

9.  Given this data structure, return a new array of the same structure but
    with the sub arrays being ordered (alphabetically or numerically as
    appropriate) in descending order.

      arr = [['b', 'c', 'a'], [2, 1, 3], ['blue', 'black', 'green']]

    A:  arr.map do |sub_arr|
          sub_arr.sort{|a, b| b <=> a}
        end

10. Given the following data structure and without modifying the original
    array, use the map method to return a new array identical in structure to
    the original but where the value of each integer is incremented by 1.

        [{a: 1}, {b: 2, c: 3}, {d: 4, e: 5, f: 6}]

    A:  arr = [{a: 1}, {b: 2, c: 3}, {d: 4, e: 5, f: 6}]
        arr.map do |elem|
          hsh = {}
          elem.each do |k,v|
            hsh[k] = v + 1
          end
          hsh
        end

11. Given the following data structure use a combination of methods,
    including either the select or reject method, to return a new array
    identical in structure to the original but containing only the integers
    that are multiples of 3.

          arr = [[2], [3, 5, 7], [9], [11, 13, 15]]

      A:  arr.map do |elem|
            elem.select{ |x| x % 3 == 0 }
          end
12. Given the following data structure, and without using the
    Array#to_hmethod, write some code that will return a hash where the key is
    the first item in each sub array and the value is the second item.

          arr = [[:a, 1],
                 ['b', 'two'],
                 ['sea', {c: 3}],
                 [{a: 1, b: 2, c: 3, d: 4}, 'D']
                ]

    A: arr.map { |(zero, one)| {zero => one} }

13. Given the following data structure, return a new array containing the same
    sub-arrays as the original but ordered logically by only taking into
    consideration the odd numbers they contain.

      arr = [[1, 6, 7], [1, 4, 9], [1, 8, 3]]

    A:  arr.sort_by do |elem|
          elem.select{|x| x.odd?}
        end

14. Given this data structure write some code to return an array containing the
    colors of the fruits and the sizes of the vegetables. The sizes should be
    uppercase and the colors should be capitalized.

      hsh = {
        'grape' => {type: 'fruit', colors: ['red', 'green'], size: 'small'},
        'carrot' => {type: 'vegetable', colors: ['orange'], size: 'medium'},
        'apple' => {type: 'fruit', colors: ['red', 'green'], size: 'medium'},
        'apricot' => {type: 'fruit', colors: ['orange'], size: 'medium'},
        'marrow' => {type: 'vegetable', colors: ['green'], size: 'large'},
      }

    A:  hsh.each_with_object([]) do |(_, v), obj|
          if v[:type] == 'fruit'
            obj << v[:colors].map{|elem| elem.capitalize}
          else
            obj << v[:size].upcase
          end
        end

15. Given this data structure write some code to return an array which contains
    only the hashes where all the integers are even.

      arr = [{a: [1, 2, 3]}, {b: [2, 4, 6], c: [3, 6], d: [4]}, {e: [8], f: [6, 10]}]

    A:  arr.select do |elem|
          elem.all? do |_, v|
            v.all?{|x| x.even?}
          end
        end

16. Write a method that returns one UUID when called with no parameters.

    A:  def get_uuid
          def get_section(number_of_digits)
            section = ''
            number_of_digits.times do
              section << get_digit
            end
            section
          end
          def get_digit
            d = rand(0..15)
            format("%x", d)
          end
          uuid = ''
          section_lengths = [8, 4, 4, 4, 12]
          i = 0
          while i < section_lengths.size
            uuid << get_section(section_lengths[i])
            i += 1
            uuid << '-' unless i == section_lengths.size
          end
          uuid
        end
